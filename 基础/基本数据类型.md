# 基本数据类型

## 布尔型

true或false

```
let x = true;
let y: bool = false;

// ⭐️ 没有TRUE，FALSE，1，0
```

## 字符型

单个Unicode数量值

```
let x = 'x';
let y = '😎';
```

### i8,i16,i32,i64,i128

固定大小（比特）有符号(+/-)整型

| 数据类型 | 最小值                                   | 最大值                                  |
| -------- | ---------------------------------------- | --------------------------------------- |
| i8       | -128                                     | 127                                     |
| i16      | -32768                                   | 32767                                   |
| i32      | -2147483648                              | 2147483647                              |
| i64      | -9223372036854775808                     | 9223372036854775807                     |
| i128     | -170141183460469231731687303715884105728 | 170141183460469231731687303715884105727 |

💡 最小值和最大值都是基于二进制浮点运算的IEEE标准。从-2^(n-1)到2^(n-1)-1。您可以使用**min_value()**和**max_value()**来寻找每个整数类型的最小值和最大值。例如，i8::min_value();【译者注：println!("{}",i8::min_value());】

## u8,u16,u32,u64,u128

固定大小（比特）无符号(+)整型

| 数据类型 | 最小值 | 最大值                                  |
| -------- | ------ | --------------------------------------- |
| u8       | 0      | 255                                     |
| u16      | 0      | 65535                                   |
| u32      | 0      | 4294967295                              |
| u64      | 0      | 18446744073709551615                    |
| u128     | 0      | 340282366920938463463374607431768211455 |

💡 和有符号数一样，最小值和最大值都基于二进制浮点运算的IEEE标准。从0到2^(n)-1。您可以使用相同的方式**min_value()**和**max_value()**来寻找每个整数类型的最小值和最大值。例如，u8::min_value();【译者注：println!("{}",i8::min_value());】

## isize

变长有符号(+/-)整型

这覆盖了所有有符号整型的数据类型，但内存根据指针的大小进行分配。最小值和最大值类似于i64。

## usize

变长无符号(+)整型

这覆盖了所有无符号整型的数据类型，但内存根据指针的大小进行分配。最小值和最大值类似于u64

## f32

32位浮点型

和其他编程语言的float相似，**单精度**。

💡 应该避免使用f32，除非您需要严重减小内存消耗或进行低级优化，当目标硬件不支持双精度或单精度比双精度更快。

## f64

64位浮点型

类似其他编程语言的double，**双精度**。

## 数组

固定长度的相同数据类型元素列表

```
let a = [1,2,3]; //a[0] = 1, a[2] = 2, a[2] = 3
let mut b = [1, 2, 3];

let e = ["my value"; 3]; //["my value", "my value", "my value"]

println!("{:?}", a); //[1, 2, 3]
println!("{:#?}", a);
/*
[
    1,
    2,
    3
]
*/
```

⭐️ 默认情况下，数组是不可变的，即便是带了mut，不能改变其元素个数。

> 🔎 若您正在寻找动态/变长数组，您可以使用**Vec**。向量可以包含任何类型的元素，但所有的元素必须属于同一数据类型。

## 元组

固定长度的不用（或相同）数据类型元素的有序列表

```
let a = (1, 1.5, true, 'a', "Hello world!");
 //a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = "Hello world!"

let b: (i32, f64) = (1, 1.5);

let (c, d) = b; //c=1, d=1.5
let (e, _, _, f) = a; //e=1, f= "Hello world!", _表示不感兴趣的项

let g = (0,); //单个元素的元组 【译者注：如果元组中只包含一个元素，应该在后面添加一个逗号，以区分括号表达式和元组】
 
let h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)
println!("{:?}", a); //(1, 1.5, true, 'a', "Hello world!")
```

⭐️ 默认情况下，元组也是不可改变的，即便带了mut，不能改变其元素个数。而且，若您想要改变元素的值，新值应该和旧值有同样的数据类型。

## 切片

动态长度引用其他数据类型

考虑到您想获取/传递数组的一部分或任何其他数据结构。Rust不允许将其拷贝到另一个数组（或相同的数据结构），而是允许创建一个视图(view)/引用来仅访问该部分数据。它可以是可变也可以是不可变的。

```
let a:[i32; 4] = [1, 2, 3, 4]; //父亲数组

let b: &[i32] = &a; //对整个数组切片
let c = &a[0..4]; //从位置0到4（不包括4）
let d = &a[..]; //对整个数组切片

let e = &a[1..3]; //[2，3]
let f = &a[1..]; //[2, 3, 4]
let g = &a[..3]; //[1, 2, 3]
```

## str

```
let a = "Hello, world."; //a: &'static str
let b: &str = "こんにちは, 世界!";
```

⭐️ 它是不可变/静态分配的切片，它包含存储在内存中某处的未知大小的UTF-8码点序列。**&str**是用于借用并将整个数组赋值给给定的变量绑定。

> 🔎 [String](https://doc.rust-lang.org/std/string/struct.String.html)是堆分配的字符串。该字符串是可增长的，并且保证是UTF-8。它们通常是通过使用to_string()或String::from()方法从字符串切片而创建的。例如，"Hello".to_string(); String::from("Hello")；

💡 一般的，当您需要所有权时，您应该使用*String**，但您只需要借用一个字符串，可以使用***&str**。

## 函数

正如我们在函数部分讨论的那样，b是一个指向plus_one函数的函数指针。

```
fn plus_one(a: i32) -> i32 {
    a + 1
}

fn main() {
    let b: fn(i32) -> i32 = plus_one;
    let c = b(5); //6
}
```